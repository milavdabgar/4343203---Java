[TOC]

# 4341602 - Java: Winter 2023 Paper Solution
## Q1a: List out basic concepts of Java OOP. Explain any one in detail.

Basic Concepts of Java OOP (Object-Oriented Programming):

1. **Classes and Objects**: Classes are blueprints for objects. They define the properties (attributes) and behaviors (methods) that objects of that class will have. Objects are instances of classes.

2. **Encapsulation**: Encapsulation refers to the bundling of data (attributes) and methods that operate on the data into a single unit or class. It hides the internal state of an object from the outside world and only exposes the necessary functionalities.

3. **Inheritance**: Inheritance is a mechanism in which a new class inherits properties and behaviors from an existing class. The new class (subclass or derived class) can reuse the code of the existing class (superclass or base class) and can also add its own unique features.

4. **Polymorphism**: Polymorphism allows objects of different classes to be treated as objects of a common superclass. It allows methods to be called on objects of different classes through a common interface, often resulting in different behaviors depending on the type of object.

5. **Abstraction**: Abstraction is the process of hiding the implementation details and showing only the essential features of the object. It helps in reducing programming complexity and effort.

6. **Association**: Association represents a relationship between two or more classes where objects of one class are connected with objects of another class through a specific type of relationship. It can be one-to-one, one-to-many, or many-to-many.

7. **Composition**: Composition is a special form of association where one class contains objects of another class as part of its state. The composed objects cannot exist independently of the containing class.

One of the concepts I'll explain in detail is Inheritance:

**Inheritance**:

Inheritance is one of the fundamental concepts of object-oriented programming. It allows a class (subclass or derived class) to inherit properties and behaviors from another class (superclass or base class). This promotes code reusability and establishes a hierarchical relationship between classes.

**Example**:

```java
// Base class or superclass
class Animal {
    void eat() {
        System.out.println("Animal is eating...");
    }
}

// Derived class or subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog is barking...");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // inherited from Animal
        dog.bark(); // unique to Dog
    }
}
```

In this example, `Animal` is the superclass, and `Dog` is the subclass. The `Dog` class inherits the `eat()` method from the `Animal` class. By using inheritance, we can avoid rewriting the `eat()` method in the `Dog` class, thus promoting code reuse.

Inheritance supports the concept of **code extensibility**, as the subclass can add its own unique features (such as the `bark()` method in this example) while retaining the features of the superclass.

Inheritance also facilitates **polymorphism**, as objects of the subclass can be treated as objects of the superclass, enabling more flexible and generic code.

## Q1b: Explain JVM in detail.

The Java Virtual Machine (JVM) is a crucial component of the Java Runtime Environment (JRE). It plays a central role in executing Java bytecode, which is the compiled form of Java source code. Below, I'll explain the JVM in detail:

**1. Execution Environment**:
   - The JVM provides a runtime environment for executing Java bytecode. It abstracts away the underlying hardware and operating system details, providing platform independence.
   - JVM implementations are available for various platforms, including Windows, Linux, macOS, and others.

**2. Just-In-Time (JIT) Compilation**:
   - The JVM employs a combination of interpretation and Just-In-Time (JIT) compilation techniques for bytecode execution.
   - Initially, bytecode is interpreted, which involves executing the bytecode instructions one by one. This allows for quick startup and adaptive optimization.
   - As the program runs, the JVM identifies frequently executed code segments (hot spots) and applies JIT compilation to translate these segments into native machine code for improved performance.

**3. Memory Management**:
   - The JVM manages memory allocation and deallocation for Java objects through automatic memory management, known as garbage collection.
   - It divides the memory into different areas such as the heap, method area (or permgen space), and stack.
   - The heap is used for storing objects dynamically allocated during program execution. Garbage collection is responsible for reclaiming memory occupied by unreachable objects in the heap.
   - The stack is used for storing method invocations and local variables.

**4. Class Loading and Dynamic Class Loading**:
   - The JVM dynamically loads Java classes into memory as they are referenced during program execution.
   - Class loading involves locating the binary representation of a class, reading it into memory, and then defining it within the JVM.
   - JVM supports dynamic class loading, allowing classes to be loaded at runtime based on specific conditions or requirements, such as through the use of reflection or custom class loaders.

**5. Security and Sandboxing**:
   - The JVM incorporates various security features to ensure safe execution of Java programs.
   - Security Manager: It defines a security policy that specifies the permissions granted to Java code based on its origin and other factors.
   - Bytecode Verification: Before executing bytecode, the JVM performs bytecode verification to ensure it adheres to the language specifications, preventing malicious code from being executed.

**6. Performance Monitoring and Profiling**:
   - JVMs often include tools for performance monitoring and profiling, allowing developers to analyze the runtime behavior of Java applications.
   - These tools provide insights into CPU utilization, memory usage, garbage collection activity, and other performance-related metrics, helping developers optimize their code.

In summary, the JVM provides a robust execution environment for Java programs, abstracting away hardware and operating system details while offering features such as memory management, dynamic class loading, security, and performance monitoring. Its ability to execute Java bytecode efficiently makes it a key component of the Java platform, enabling the development of portable and scalable applications.

## Q1c: Write a program in java to print Fibonacci series for n terms.

Sure, here's a Java program to print the Fibonacci series for n terms:

```java
import java.util.Scanner;

public class FibonacciSeries {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of terms in the Fibonacci series: ");
        int n = scanner.nextInt();
        scanner.close();

        System.out.println("Fibonacci series for " + n + " terms:");
        int firstTerm = 0, secondTerm = 1;

        // Print the first two terms
        System.out.print(firstTerm + " " + secondTerm + " ");

        // Generate and print the rest of the terms
        for (int i = 3; i <= n; i++) {
            int nextTerm = firstTerm + secondTerm;
            System.out.print(nextTerm + " ");
            firstTerm = secondTerm;
            secondTerm = nextTerm;
        }
    }
}
```

This program prompts the user to enter the number of terms (n) they want in the Fibonacci series. It then calculates and prints the Fibonacci series for n terms. The Fibonacci series starts with 0 and 1, and each subsequent term is the sum of the previous two terms. The loop iterates from the third term onwards, calculating each term based on the previous two terms. Finally, it prints each term of the Fibonacci series.

## Q1c: Write a program in java to find out minimum from any ten numbers using command line argument.

Sure, here's a Java program that finds the minimum from any ten numbers using command-line arguments:

```java
public class MinimumNumberFinder {
    public static void main(String[] args) {
        if (args.length != 10) {
            System.out.println("Please provide exactly 10 numbers as command line arguments.");
            return;
        }

        // Parse the command line arguments and find the minimum
        int min = Integer.parseInt(args[0]); // Assume the first number as the minimum initially

        for (int i = 1; i < args.length; i++) {
            int num = Integer.parseInt(args[i]);
            if (num < min) {
                min = num; // Update min if a smaller number is found
            }
        }

        System.out.println("The minimum number among the given ten numbers is: " + min);
    }
}
```

To run this program, compile it using `javac MinimumNumberFinder.java` and then execute it with ten numbers as command-line arguments:

```bash
java MinimumNumberFinder 5 3 9 2 8 1 7 6 4 10
```

This will output:

```
The minimum number among the given ten numbers is: 1
```

Ensure that exactly ten numbers are provided as command-line arguments when running the program, otherwise, it will display an error message.

## Q2a: What is Java wrapper class? Explain with example.

In Java, a wrapper class is a class that encapsulates (or "wraps") primitive data types into objects. While primitive data types represent simple values, wrapper classes provide a way to treat these values as objects. This is particularly useful when dealing with collections, as many collection classes in Java require objects, not primitives.

The Java platform provides a set of predefined wrapper classes for each primitive data type:

1. `Byte` for `byte`
2. `Short` for `short`
3. `Integer` for `int`
4. `Long` for `long`
5. `Float` for `float`
6. `Double` for `double`
7. `Character` for `char`
8. `Boolean` for `boolean`

Here's an example to illustrate the usage of wrapper classes:

```java
public class WrapperExample {
    public static void main(String[] args) {
        // Using primitive data types
        int num1 = 10;
        double num2 = 3.14;
        char letter = 'A';
        boolean flag = true;

        // Using wrapper classes
        Integer numObj1 = Integer.valueOf(num1); // Wrapping int into Integer
        Double numObj2 = Double.valueOf(num2);   // Wrapping double into Double
        Character charObj = Character.valueOf(letter); // Wrapping char into Character
        Boolean flagObj = Boolean.valueOf(flag); // Wrapping boolean into Boolean

        // Displaying values
        System.out.println("Wrapped Integer value: " + numObj1);
        System.out.println("Wrapped Double value: " + numObj2);
        System.out.println("Wrapped Character value: " + charObj);
        System.out.println("Wrapped Boolean value: " + flagObj);
    }
}
```

In this example, we have primitive variables (`num1`, `num2`, `letter`, `flag`) representing different data types. We then use the corresponding wrapper classes (`Integer`, `Double`, `Character`, `Boolean`) to wrap these primitive values into objects (`numObj1`, `numObj2`, `charObj`, `flagObj`). Finally, we print out the values of these wrapped objects.

Wrapper classes also provide utility methods to convert strings into primitive values and vice versa, and to perform various operations on the wrapped values. They also facilitate interoperability between primitive types and objects in Java.

## Q2b: List out different features of java. Explain any two.

Java is a versatile programming language known for its rich set of features that contribute to its popularity and widespread use. Here are some key features of Java:

1. **Simple**: Java was designed to be easy to learn and use. It has a concise, readable syntax, automatic memory management (garbage collection), and eliminates complex features such as pointers and operator overloading found in languages like C++.

2. **Object-Oriented**: Java is an object-oriented programming language, which means it supports the creation of modular, reusable code through classes and objects. It embodies concepts like encapsulation, inheritance, polymorphism, and abstraction, promoting better code organization and maintenance.

3. **Platform-Independent**: Java programs are compiled into bytecode, which can be executed on any platform with a Java Virtual Machine (JVM). This "write once, run anywhere" capability makes Java platform-independent, enabling the development of cross-platform applications.

4. **Secure**: Java's security features help protect systems from malicious code and unauthorized access. It incorporates a robust security model with features like bytecode verification, class loaders, and a Security Manager that enforces access control policies.

5. **Multithreaded**: Java provides built-in support for multithreading, allowing concurrent execution of multiple threads within a single program. This enables developers to write efficient, responsive applications that can perform tasks concurrently, enhancing performance and responsiveness.

6. **Dynamic**: Java supports dynamic memory allocation and dynamic class loading, enabling applications to adapt to changing runtime conditions. Dynamic features like reflection allow Java programs to introspect and modify their own structure and behavior at runtime.

7. **High Performance**: While Java's interpreted nature might suggest slower performance compared to languages like C or C++, modern Java implementations use techniques like Just-In-Time (JIT) compilation and adaptive optimization to achieve high performance, often rivaling or surpassing native code performance.

8. **Distributed**: Java's built-in networking capabilities and Remote Method Invocation (RMI) framework facilitate the development of distributed applications. Java's networking APIs allow seamless communication between distributed components, making it suitable for building networked systems.

Let's delve into explanations for two of these features:

**1. Platform-Independence**:
Java achieves platform-independence through its bytecode compilation. When you compile a Java source file, it's translated into bytecode, which is a platform-independent intermediate representation of the program. This bytecode can then be executed on any device or platform that has a Java Virtual Machine (JVM). The JVM interprets the bytecode and translates it into machine code that is specific to the underlying hardware and operating system. This allows Java programs to run on diverse platforms without modification, making it an ideal choice for developing cross-platform applications.

**2. Object-Oriented**:
Java is a pure object-oriented programming language, which means it revolves around the concept of objects. Everything in Java is an object, which has attributes (fields or properties) and behaviors (methods). Object-oriented programming promotes modularity, reusability, and extensibility of code. Encapsulation ensures that the internal state of an object is hidden from the outside world, providing data security and abstraction. Inheritance allows classes to inherit properties and behaviors from other classes, facilitating code reuse and hierarchical organization. Polymorphism enables objects to exhibit different behaviors based on their types, enhancing flexibility and code maintainability. Java's object-oriented features make it well-suited for building large-scale, maintainable software systems.

## Q2c: What is method overload in Java ? Explain with example.

Method overloading in Java refers to the ability to define multiple methods within the same class with the same name but different parameter lists. These methods can have different numbers or types of parameters. Java distinguishes between overloaded methods based on the number, type, and sequence of their parameters.

When a method is invoked, Java determines which overloaded method to call based on the arguments provided at the time of invocation. This process is known as compile-time polymorphism or static polymorphism because the decision on which method to call is made by the compiler at compile time, rather than at runtime.

Here's an example to illustrate method overloading in Java:

```java
public class Calculator {
    
    // Method to add two integers
    public int add(int a, int b) {
        return a + b;
    }
    
    // Method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    // Method to add two doubles
    public double add(double a, double b) {
        return a + b;
    }
    
    // Method to concatenate two strings
    public String add(String a, String b) {
        return a + b;
    }
    
    // Method to add an integer and a double
    public double add(int a, double b) {
        return a + b;
    }
}
```

In this example, the `Calculator` class contains multiple overloaded `add` methods:

1. `add(int a, int b)`: Adds two integers and returns the result.
2. `add(int a, int b, int c)`: Adds three integers and returns the result.
3. `add(double a, double b)`: Adds two doubles and returns the result.
4. `add(String a, String b)`: Concatenates two strings and returns the result.
5. `add(int a, double b)`: Adds an integer and a double and returns the result.

These methods have the same name (`add`) but different parameter lists. Depending on the arguments passed during the method invocation, Java determines which overloaded method to call. For example:

```java
public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        
        int sum1 = calculator.add(5, 3); // Calls add(int a, int b)
        int sum2 = calculator.add(5, 3, 2); // Calls add(int a, int b, int c)
        double sum3 = calculator.add(2.5, 3.7); // Calls add(double a, double b)
        String concatenatedString = calculator.add("Hello ", "world!"); // Calls add(String a, String b)
        double sum4 = calculator.add(5, 3.7); // Calls add(int a, double b)
        
        System.out.println("Sum 1: " + sum1);
        System.out.println("Sum 2: " + sum2);
        System.out.println("Sum 3: " + sum3);
        System.out.println("Concatenated String: " + concatenatedString);
        System.out.println("Sum 4: " + sum4);
    }
}
```

Output:
```
Sum 1: 8
Sum 2: 10
Sum 3: 6.2
Concatenated String: Hello world!
Sum 4: 8.7
```

In this example, depending on the type and number of arguments provided, Java resolves the method calls to the appropriate overloaded `add` method during compilation.

## Q2a: Explain Garbage collection in java.

Garbage collection in Java is the automatic process of reclaiming memory occupied by objects that are no longer in use or reachable by the application. It is a fundamental feature of the Java Virtual Machine (JVM) that helps manage memory efficiently, prevents memory leaks, and reduces the risk of memory-related errors such as segmentation faults.

Here's how garbage collection works in Java:

1. **Object Allocation**: When you create objects in Java using the `new` keyword, memory is allocated from the heap to store those objects. The JVM keeps track of all allocated memory.

2. **Reachability Analysis**: The JVM periodically performs reachability analysis starting from a set of root objects, typically references held by active threads, static variables, and local variables. It traverses the object graph, marking objects that are reachable as live objects. Objects that are not reachable from any root are considered garbage.

3. **Garbage Collection Process**: Once the reachability analysis identifies garbage objects, the garbage collector (GC) is invoked to reclaim the memory occupied by those objects. The garbage collector uses different algorithms to reclaim memory, such as the Mark-Sweep algorithm, Mark-Compact algorithm, or Generational Garbage Collection.

4. **Reclamation and Compaction**: During garbage collection, the memory occupied by garbage objects is reclaimed, and the memory space is compacted to reduce fragmentation. This involves moving live objects together to create contiguous free space.

5. **Finalization**: Before reclaiming the memory of objects, the JVM calls the `finalize()` method of those objects (if it's overridden) to perform any necessary cleanup operations. However, it's important to note that the `finalize()` method is deprecated and is not guaranteed to be called promptly or at all by the garbage collector.

6. **Performance Considerations**: Garbage collection can impact application performance, as it involves stopping application threads temporarily to perform garbage collection tasks. To minimize the impact on application responsiveness, modern JVMs use techniques like concurrent garbage collection, where garbage collection runs concurrently with the application, and incremental garbage collection, where garbage collection tasks are divided into smaller increments.

Here are some key benefits of garbage collection in Java:

- **Automatic Memory Management**: Developers do not need to manually allocate and deallocate memory, reducing the risk of memory leaks and memory-related bugs.
- **Simplified Memory Management**: Garbage collection eliminates the need for explicit memory management techniques like manual memory deallocation, reducing the complexity of programming.
- **Improved Application Reliability**: By preventing memory leaks and segmentation faults caused by dangling pointers, garbage collection enhances the reliability and stability of Java applications.

Overall, garbage collection is a critical feature of the Java platform that helps manage memory efficiently, allowing developers to focus on writing robust and reliable software.

## Q2b: Explain final keyword in Java with example.

In Java, the `final` keyword is used to restrict the behavior of classes, methods, and variables. When applied to different elements, it signifies different meanings:

1. **Final Variables**: When applied to a variable, the `final` keyword indicates that the variable's value cannot be changed once initialized. It creates a constant.

2. **Final Methods**: When applied to a method, the `final` keyword indicates that the method cannot be overridden by subclasses. It effectively prevents method overriding.

3. **Final Classes**: When applied to a class, the `final` keyword indicates that the class cannot be subclassed. It prevents inheritance.

Here's how `final` keyword works with examples:

**1. Final Variables:**
```java
public class FinalExample {
    // Declaring final variable
    final int constantValue = 10;

    public static void main(String[] args) {
        FinalExample obj = new FinalExample();
        // Trying to modify the final variable will result in a compilation error
        // obj.constantValue = 20; // Compilation error: The final field FinalExample.constantValue cannot be assigned
        System.out.println("Constant value: " + obj.constantValue);
    }
}
```

In this example, `constantValue` is declared as a final variable. Attempting to modify its value after initialization will result in a compilation error.

**2. Final Methods:**
```java
public class Parent {
    // Final method
    public final void display() {
        System.out.println("This is a final method.");
    }
}

public class Child extends Parent {
    // Trying to override the final method will result in a compilation error
    // @Override
    // public void display() {
    //     System.out.println("Attempting to override a final method.");
    // }
}
```

In this example, the `display()` method in the `Parent` class is declared as final. Attempting to override this method in the `Child` class will result in a compilation error.

**3. Final Classes:**
```java
final public class FinalClass {
    // Some code
}

// Trying to subclass a final class will result in a compilation error
// class SubClass extends FinalClass {
//     // Some code
// }
```

In this example, the `FinalClass` is declared as a final class. Attempting to subclass `FinalClass` will result in a compilation error.

In summary, the `final` keyword in Java is used to create constants, prevent method overriding, and prevent class inheritance, depending on where it's applied. It helps enforce immutability, security, and design constraints in Java programs.

## Q2c: What is constructor in Java? Explain parameterized constructor with example.

In Java, a constructor is a special type of method that is automatically called when an instance (object) of a class is created. It is used to initialize the newly created object and perform any necessary setup operations. Constructors have the same name as the class and do not have a return type, not even `void`.

There are two types of constructors in Java:

1. **Default Constructor**: A constructor with no parameters is called a default constructor. If you do not explicitly define any constructors in a class, Java provides a default constructor automatically. Its purpose is to initialize instance variables to default values.

2. **Parameterized Constructor**: A constructor with parameters is called a parameterized constructor. It allows you to initialize instance variables with specified values when the object is created. Parameterized constructors give more flexibility and control over object initialization.

Here's an example of a parameterized constructor:

```java
public class Person {
    private String name;
    private int age;
    
    // Parameterized constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Getter methods
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public static void main(String[] args) {
        // Creating objects using parameterized constructor
        Person person1 = new Person("Alice", 30);
        Person person2 = new Person("Bob", 25);
        
        // Accessing object properties
        System.out.println("Person 1 - Name: " + person1.getName() + ", Age: " + person1.getAge());
        System.out.println("Person 2 - Name: " + person2.getName() + ", Age: " + person2.getAge());
    }
}
```

In this example:

- We have a `Person` class with private instance variables `name` and `age`.
- The `Person` class has a parameterized constructor that takes two parameters: `name` and `age`.
- Inside the constructor, the values of `name` and `age` parameters are assigned to the corresponding instance variables using the `this` keyword.
- We then create two `Person` objects (`person1` and `person2`) using the parameterized constructor, passing different values for `name` and `age`.
- Finally, we use getter methods (`getName()` and `getAge()`) to retrieve the values of `name` and `age` for each object and print them out.

## Q3a: Explain super keyword in Java with example.

In Java, the `super` keyword is used to refer to the superclass (parent class) of the current object or to access members (fields or methods) of the superclass. It is often used in subclasses (child classes) to access superclass constructors, methods, or variables. The `super` keyword is particularly useful when there is a need to differentiate between superclass and subclass members with the same name.

Here are the main uses of the `super` keyword:

1. **Accessing Superclass Constructors**: The `super()` constructor call is used to invoke the constructor of the superclass from within the constructor of the subclass. It is typically used when the subclass constructor needs to perform additional initialization that is not handled by the superclass constructor.

2. **Accessing Superclass Methods and Variables**: The `super` keyword can also be used to access methods and variables of the superclass. This is useful when a subclass overrides a method from the superclass but still needs to call the superclass implementation of that method.

Here's an example to illustrate the use of the `super` keyword:

```java
class Vehicle {
    int speed;

    Vehicle(int speed) {
        this.speed = speed;
    }

    void display() {
        System.out.println("Vehicle speed: " + speed + " km/h");
    }
}

class Car extends Vehicle {
    int mileage;

    Car(int speed, int mileage) {
        super(speed); // invoking superclass constructor
        this.mileage = mileage;
    }

    // overriding superclass method
    void display() {
        super.display(); // calling superclass method
        System.out.println("Car mileage: " + mileage + " km/l");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car(100, 15);
        car.display(); // invoking overridden method
    }
}
```

In this example:

- We have a superclass `Vehicle` with a field `speed` and a constructor to initialize the `speed`.
- We then have a subclass `Car` that extends the `Vehicle` class. The `Car` class has an additional field `mileage` and a constructor to initialize both `speed` and `mileage`. Inside the `Car` constructor, we use `super(speed)` to call the constructor of the superclass `Vehicle`.
- The `Car` class also overrides the `display()` method of the superclass. Inside the overridden `display()` method, we use `super.display()` to call the `display()` method of the superclass before displaying the `mileage` of the car.
- In the `main()` method, we create an instance of the `Car` class and invoke its `display()` method. This will print both the vehicle speed and the car mileage.

## Q3b: List out different types of inheritance in Java. Explain multilevel inheritance.

In Java, there are several types of inheritance, each representing different relationships between classes. These types include:

1. **Single Inheritance**: In single inheritance, a subclass inherits from only one superclass. Java supports single inheritance only, meaning a class can have only one direct superclass.

2. **Multilevel Inheritance**: In multilevel inheritance, a subclass inherits from a superclass, and then another subclass inherits from the first subclass, creating a chain of inheritance.

3. **Hierarchical Inheritance**: In hierarchical inheritance, multiple subclasses inherit from a single superclass, creating a tree-like structure.

4. **Multiple Inheritance** (not supported in Java): In multiple inheritance, a subclass inherits from multiple superclasses. Java does not support multiple inheritance of classes to avoid the diamond problem, where the same member can be inherited from multiple superclasses, leading to ambiguity.

5. **Hybrid Inheritance** (not supported in Java): Hybrid inheritance is a combination of multiple inheritance and hierarchical inheritance. It is also not supported in Java to avoid complications and ambiguity.

Let's focus on explaining **multilevel inheritance**:

**Multilevel Inheritance**:

In multilevel inheritance, a subclass extends a class that is itself a subclass of another class. This creates a chain of inheritance, where each subclass inherits the properties and behaviors of its immediate superclass, as well as all of its ancestor classes up the hierarchy chain.

Here's an example of multilevel inheritance:

```java
// Superclass
class Animal {
    void eat() {
        System.out.println("Animal is eating...");
    }
}

// Subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog is barking...");
    }
}

// Subclass inheriting from Dog
class Labrador extends Dog {
    void color() {
        System.out.println("Labrador is black...");
    }
}

public class Main {
    public static void main(String[] args) {
        Labrador labrador = new Labrador();
        labrador.eat();   // inherited from Animal
        labrador.bark();  // inherited from Dog
        labrador.color(); // unique to Labrador
    }
}
```

In this example:

- `Animal` is the superclass, `Dog` is a subclass of `Animal`, and `Labrador` is a subclass of `Dog`.
- `Labrador` inherits the `eat()` method from `Animal`, the `bark()` method from `Dog`, and it adds its own method `color()` to represent the unique characteristic of a Labrador.
- When an instance of `Labrador` is created, it can access methods from all levels of the inheritance hierarchy, including methods from its superclass (`Animal`) and its immediate superclass (`Dog`). Additionally, it can access methods specific to the `Labrador` class.
  

Multilevel inheritance allows for the creation of a hierarchy of classes, where each subclass can inherit and extend the functionality of its parent classes, leading to better code organization and reuse. However, it's important to use multilevel inheritance judiciously to avoid creating overly complex class hierarchies.

## Q3c: What is Java interface? Explain multiple inheritance with example.

In Java, an interface is a reference type similar to a class that defines a set of abstract methods and constants. An interface can also contain default methods, static methods, and nested types. It provides a way to achieve abstraction and multiple inheritance of type. Interfaces are used to specify a contract that classes must adhere to by implementing the methods declared in the interface.

Here's the syntax for declaring an interface in Java:

```java
interface MyInterface {
    // Constant declarations
    int CONSTANT1 = 1;
    String CONSTANT2 = "Hello";

    // Abstract method declarations
    void method1();
    int method2(int x);
}
```

In the above example, `MyInterface` is an interface that declares a constant `CONSTANT1` and `CONSTANT2`, along with two abstract methods `method1()` and `method2(int x)`.

Now, let's discuss multiple inheritance with interfaces:

**Multiple Inheritance with Interfaces**:

Java supports multiple inheritance of type through interfaces, but it does not support multiple inheritance of implementation. This means a class can implement multiple interfaces, inheriting abstract method signatures from all of them, but it cannot extend multiple classes.

Here's an example to illustrate multiple inheritance with interfaces:

```java
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class MyClass implements A, B {
    // Implementation of methodA from interface A
    public void methodA() {
        System.out.println("Method A implementation");
    }

    // Implementation of methodB from interface B
    public void methodB() {
        System.out.println("Method B implementation");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.methodA(); // Method A implementation
        obj.methodB(); // Method B implementation
    }
}
```

In this example:

- `interface A` declares an abstract method `methodA()`.
- `interface B` declares an abstract method `methodB()`.
- `MyClass` implements both interfaces `A` and `B` and provides implementations for both `methodA()` and `methodB()`.
- In the `main` method, we create an instance of `MyClass` and call both `methodA()` and `methodB()`, which will print their respective implementation messages.

By implementing multiple interfaces, `MyClass` inherits the abstract method signatures from both `A` and `B`, effectively achieving multiple inheritance of type. This allows for increased flexibility and code reuse while avoiding the complications associated with multiple inheritance of implementation.

## Q3a: Explain Java static keyword with example.

In Java, the `static` keyword is used to define members (variables and methods) that belong to the class itself, rather than to instances of the class (objects). These members are shared among all instances of the class and can be accessed directly through the class name, without the need to create an object of the class.

Here's how `static` keyword works with examples:

1. **Static Variables (Class Variables)**: Static variables are shared among all instances of a class. They are declared using the `static` keyword and are initialized only once, at the start of the program execution.

```java
class MyClass {
    static int count = 0; // static variable

    MyClass() {
        count++; // increment count on each object creation
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj1 = new MyClass();
        MyClass obj2 = new MyClass();
        MyClass obj3 = new MyClass();

        System.out.println("Total objects created: " + MyClass.count); // accessing static variable
    }
}
```

In this example, `count` is a static variable that keeps track of the total number of objects created from the `MyClass`. Since it's static, its value is shared among all instances of the class. The output will be `Total objects created: 3`.

2. **Static Methods (Class Methods)**: Static methods are associated with the class itself, rather than with instances of the class. They are declared using the `static` keyword and can be called directly through the class name, without the need to create an object of the class.

```java
class MathUtils {
    static int add(int a, int b) { // static method
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = MathUtils.add(5, 3); // calling static method
        System.out.println("Result of addition: " + result);
    }
}
```

In this example, `add` is a static method of the `MathUtils` class. It can be called directly using the class name `MathUtils.add(5, 3)` without creating an object of `MathUtils`.

**Key Points**:
- Static members belong to the class, not to individual objects.
- They can be accessed using the class name directly.
- Static variables are initialized only once, at the start of the program execution.
- Static methods cannot access non-static members directly, as they are not associated with any specific instance of the class.
- Static members are commonly used for utility methods, constants, and for maintaining global state within a class.

## Q3b: Explain different access controls in Java.

In Java, access controls are used to restrict the visibility and accessibility of classes, variables, methods, and constructors. This helps in encapsulating the implementation details, promoting code reusability, and enhancing security. Java provides four types of access controls, also known as access modifiers:

1. **Default (No Modifier)**:
   - Accessible within the same package only.
   - If no access modifier is specified, it is considered as default.
   - Members with default access are not accessible outside the package.

```java
package com.example;

class MyClass {
    void method() {
        // This method is accessible within the same package
    }
}
```

2. **Public**:
   - Accessible from anywhere, both within and outside the package.
   - Public members can be accessed by any other class.

```java
package com.example;

public class MyClass {
    public void method() {
        // This method is accessible from anywhere
    }
}
```

3. **Private**:
   - Accessible only within the same class.
   - Private members are not visible outside the class, including subclasses.

```java
package com.example;

public class MyClass {
    private int num;

    private void method() {
        // This method is accessible only within this class
    }
}
```

4. **Protected**:
   - Accessible within the same package and by subclasses, even if they are in different packages.
   - Protected members are not accessible by classes outside the package that are not subclasses.

```java
package com.example;

public class MyClass {
    protected int num;

    protected void method() {
        // This method is accessible within the same package and by subclasses
    }
}
```

These access controls provide a way to manage the visibility and accessibility of members in Java classes, allowing developers to design and implement classes with appropriate encapsulation and access restrictions based on their requirements. Proper use of access controls helps in creating more modular, maintainable, and secure Java applications.

## Q3c: What is Java package? Write steps to create a package in Java and give example of it.

In Java, a package is a way to organize related classes and interfaces into a single namespace. It helps in avoiding naming conflicts, improving code organization, and providing access control. Packages can contain classes, interfaces, sub-packages, and other resources.

Here are the steps to create a package in Java:

1. **Choose a Package Name**: Determine a meaningful name for your package. Typically, package names are in reverse domain name notation to ensure uniqueness.

2. **Create a Directory Structure**: Create a directory structure that matches the package name. Each component of the package name corresponds to a directory in the file system.

3. **Place Java Files in the Directory**: Create Java files (`.java`) containing classes or interfaces within the directory structure. Each file should contain at most one public class or interface, and the file name should match the class or interface name.

4. **Define the Package Declaration**: At the top of each Java file, include a package declaration statement specifying the package name.

5. **Compile Java Files**: Compile the Java files using the `javac` compiler. Make sure the compiler is invoked from the root directory of the package structure.

Here's an example of creating and using a package in Java:

Suppose we want to create a package named `com.example.utils` containing a class named `StringUtils` with a method to capitalize a string.

**Step 1**: Choose a Package Name:
```
com.example.utils
```

**Step 2**: Create a Directory Structure:
```
- com
  - example
    - utils
```

**Step 3**: Place Java Files in the Directory:
Create a Java file named `StringUtils.java` containing the `StringUtils` class within the `com/example/utils` directory.

**Step 4**: Define the Package Declaration:
At the top of `StringUtils.java`, include the package declaration:
```java
package com.example.utils;
```

**Step 5**: Define the Class:
Define the `StringUtils` class with a method to capitalize a string:
```java
package com.example.utils;

public class StringUtils {
    public static String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}
```

**Step 6**: Compile Java Files:
Compile the `StringUtils.java` file. Make sure the current directory is the parent directory of `com`.
```bash
javac com/example/utils/StringUtils.java
```

After compiling, you can use the `StringUtils` class in other Java files by importing the package:
```java
import com.example.utils.StringUtils;

public class Main {
    public static void main(String[] args) {
        String str = "hello";
        String capitalized = StringUtils.capitalize(str);
        System.out.println(capitalized); // Output: Hello
    }
}
```

By following these steps, you've created and used a package in Java, demonstrating the organization and encapsulation benefits it provides.

## Q4a: Explain Java thread priorities with suitable example.

In Java, thread priorities are used to indicate the importance or urgency of a thread's execution relative to other threads. Thread priorities are represented by integer values ranging from 1 to 10, where 1 is the lowest priority and 10 is the highest priority. The default priority for a thread is typically inherited from its parent thread, but it can be explicitly set using the `setPriority()` method.

Thread priorities are used by the Java Virtual Machine's thread scheduler to determine the order in which threads are scheduled for execution. However, thread priorities are merely hints to the scheduler, and the JVM's implementation of thread scheduling may vary across different platforms.

Here's an example to illustrate Java thread priorities:

```java
public class PriorityDemo {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Worker(), "Thread 1");
        Thread thread2 = new Thread(new Worker(), "Thread 2");
        Thread thread3 = new Thread(new Worker(), "Thread 3");

        // Set thread priorities
        thread1.setPriority(Thread.MIN_PRIORITY); // Lowest priority
        thread2.setPriority(Thread.NORM_PRIORITY); // Default priority
        thread3.setPriority(Thread.MAX_PRIORITY); // Highest priority

        // Start the threads
        thread1.start();
        thread2.start();
        thread3.start();
    }

    static class Worker implements Runnable {
        public void run() {
            for (int i = 1; i <= 5; i++) {
                System.out.println(Thread.currentThread().getName() + ": " + i);
                try {
                    Thread.sleep(1000); // Sleep for 1 second
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

In this example:

- We create three threads (`thread1`, `thread2`, and `thread3`) and assign them instances of the `Worker` class, which implements the `Runnable` interface.
- We set different priorities for each thread using the `setPriority()` method. `thread1` is set to the lowest priority (`MIN_PRIORITY`), `thread2` is set to the default priority (`NORM_PRIORITY`), and `thread3` is set to the highest priority (`MAX_PRIORITY`).
- Each thread runs a simple loop printing numbers from 1 to 5 with a one-second delay between each iteration.
- When you run this program, the output may vary depending on the thread scheduler's behavior, but in general, you may observe that `thread3` (highest priority) gets more CPU time compared to the other threads, followed by `thread2` (default priority), and finally `thread1` (lowest priority). However, thread scheduling behavior is platform-dependent, and thread priorities should be used with caution as they may not always have the desired effect.

## Q4b: What is Java Thread? Explain Thread life cycle.

In Java, a thread is the smallest unit of execution within a process. It represents an independent path of execution that can run concurrently with other threads in a Java program. Threads allow programs to perform multiple tasks simultaneously, making efficient use of CPU resources and enabling concurrent and parallel processing.

**Thread Life Cycle**:

The life cycle of a thread in Java consists of several states, and a thread transitions through these states during its lifetime. The states are typically represented by constants defined in the `Thread.State` enumeration. The thread life cycle states are as follows:

1. **New**: When a thread is created but not yet started, it is in the new state. The `Thread` object has been created, but the `start()` method has not been called.

2. **Runnable**: After the `start()` method is called, the thread becomes runnable. In this state, the thread is eligible to run, but it may or may not be executing, depending on the availability of CPU resources. Once the scheduler selects the thread for execution, it moves to the running state.

3. **Running**: When the thread is executing its code, it is in the running state. The thread scheduler has allocated CPU time for the thread, and the thread's `run()` method is being executed.

4. **Blocked/Waiting**: A thread can transition to a blocked or waiting state for various reasons, such as waiting for I/O operations to complete, waiting for locks, or waiting for other threads to complete. In these cases, the thread temporarily gives up the CPU and waits for the condition to be satisfied.

5. **Timed Waiting**: Similar to the blocked/waiting state, but with a specified timeout. Threads enter this state when they invoke methods such as `sleep()` or `join()` with a timeout parameter.

6. **Terminated**: When the `run()` method of the thread completes or when the thread is explicitly terminated using the `interrupt()` method, the thread enters the terminated state. Once terminated, a thread cannot be restarted or transitioned to any other state.

Here's a simple visual representation of the thread life cycle:

```
New       ->     Runnable    ->    Running   ->   Terminated
                          |        |     ^    ^
                          v        v     |    |
                        Blocked  Waiting  |    |
                                        |    |
                                  Timed Waiting
```

Understanding the thread life cycle is crucial for writing multithreaded Java applications efficiently, as it helps in managing and coordinating the execution of concurrent tasks. It allows developers to control thread behavior, handle synchronization, and avoid common concurrency issues such as race conditions and deadlocks.

## Q4c: Write a program in java that create the multiple threads by implementing the Thread class.

Here's a simple Java program that creates multiple threads by implementing the `Thread` class:

```java
class MyThread extends Thread {
    private String threadName;

    public MyThread(String name) {
        this.threadName = name;
    }

    public void run() {
        System.out.println("Thread " + threadName + " is running.");
        try {
            // Simulating some work being done by the thread
            Thread.sleep(2000); // Sleep for 2 seconds
        } catch (InterruptedException e) {
            System.out.println("Thread " + threadName + " interrupted.");
        }
        System.out.println("Thread " + threadName + " exiting.");
    }
}

public class MultiThreadExample {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("Thread 1");
        MyThread thread2 = new MyThread("Thread 2");
        MyThread thread3 = new MyThread("Thread 3");

        // Start the threads
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

In this program:

- We define a class `MyThread` that extends the `Thread` class. This class represents a simple thread that prints a message, does some simulated work (sleeps for 2 seconds), and then exits.
- The `run()` method is overridden to define the behavior of the thread.
- In the `MultiThreadExample` class, we create three instances of `MyThread` with different names (`Thread 1`, `Thread 2`, and `Thread 3`).
- We start each thread using the `start()` method. This method initiates the execution of the thread by invoking its `run()` method in a separate thread of control.
- As a result, all three threads are running concurrently, executing their tasks independently.
- The output may vary on each run, but you'll see messages indicating that each thread is running, then after a 2-second delay, it exits.

This example demonstrates how to create multiple threads by extending the `Thread` class and starting them concurrently to achieve parallel execution of tasks.

## Q4a: List four different inbuilt exceptions of Java. Explain any one inbuilt exception.

In Java, there are many built-in exceptions provided by the Java API, which are organized in a hierarchy under the `java.lang.Exception` class. Here are four commonly encountered built-in exceptions:

1. **NullPointerException**: This exception occurs when you try to access or perform an operation on an object reference that is `null`.

2. **ArrayIndexOutOfBoundsException**: This exception occurs when you try to access an element of an array at an invalid index (i.e., an index that is less than 0 or greater than or equal to the length of the array).

3. **NumberFormatException**: This exception occurs when you try to convert a string to a numeric format (e.g., using `Integer.parseInt()` or `Double.parseDouble()`) but the string does not contain a valid numeric value.

4. **FileNotFoundException**: This exception occurs when an attempt to open a file or a file pathname specified by a string in the code fails because the file with the specified pathname does not exist or cannot be opened for reading.

Let's explain the `NullPointerException` in more detail:

**NullPointerException**:

A `NullPointerException` is one of the most common exceptions encountered by Java programmers. It occurs when you try to access or perform an operation on an object reference that is `null`, i.e., it does not refer to any object in memory.

Here's an example to illustrate a `NullPointerException`:

```java
public class NullPointerExceptionExample {
    public static void main(String[] args) {
        String str = null;
        System.out.println(str.length()); // This line will throw a NullPointerException
    }
}
```

In this example, we have a `String` variable `str` that is initialized to `null`. When we try to access the `length()` method of `str`, a `NullPointerException` will be thrown at runtime because we are attempting to invoke a method on a `null` reference.

To handle a `NullPointerException`, you can either check if the reference is `null` before accessing it or use try-catch blocks to catch and handle the exception gracefully:

```java
public class NullPointerExceptionExample {
    public static void main(String[] args) {
        String str = null;

        // Using if statement to check for null reference
        if (str != null) {
            System.out.println(str.length());
        } else {
            System.out.println("String is null.");
        }

        // Using try-catch block to handle NullPointerException
        try {
            System.out.println(str.length());
        } catch (NullPointerException e) {
            System.out.println("NullPointerException caught: " + e.getMessage());
        }
    }
}
```

It's important to handle `NullPointerExceptions` properly in your code to prevent unexpected crashes and ensure the robustness of your Java applications.

## Q4b: Explain multiple catch with suitable example in Java.

In Java, you can use multiple `catch` blocks to handle different types of exceptions that may occur within a `try` block. This allows you to handle each type of exception differently, based on the specific error conditions that may arise during the execution of the code.

Here's an example to illustrate the usage of multiple `catch` blocks:

```java
public class MultipleCatchExample {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println("Element at index 3: " + numbers[3]); // This will throw ArrayIndexOutOfBoundsException
            String str = null;
            System.out.println("Length of string: " + str.length()); // This will throw NullPointerException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("ArrayIndexOutOfBoundsException caught: " + e.getMessage());
        } catch (NullPointerException e) {
            System.out.println("NullPointerException caught: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Generic Exception caught: " + e.getMessage());
        }
    }
}
```

In this example:

- We have a `try` block containing two statements that may throw different types of exceptions:
  - Accessing an element at index 3 of an array (`numbers[3]`), which may throw an `ArrayIndexOutOfBoundsException`.
  - Attempting to get the length of a null string (`str.length()`), which may throw a `NullPointerException`.
- We have multiple `catch` blocks to handle each type of exception separately:
  - The first `catch` block catches `ArrayIndexOutOfBoundsException`, prints a message, and handles the exception.
  - The second `catch` block catches `NullPointerException`, prints a message, and handles the exception.
- We also have a generic `catch` block (`catch (Exception e)`) at the end to catch any other type of exception that may occur. This is optional but can be useful for handling unexpected exceptions or providing a fallback mechanism.

When you run this program, if an `ArrayIndexOutOfBoundsException` occurs, the first `catch` block will handle it and print a message. Similarly, if a `NullPointerException` occurs, the second `catch` block will handle it. If any other type of exception occurs, the generic `catch` block will handle it.

Using multiple `catch` blocks allows you to handle different exceptions gracefully and provide appropriate error messages or recovery mechanisms based on the specific type of exception encountered.

## Q4c: What is Java Exception? Write a program that show the use of Arithmetic Exception in Java.

In Java, an exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When an exceptional condition arises, an object representing that condition is created and thrown in the method that caused the error. This object is an instance of a subclass of the `Throwable` class, which can be either an `Exception` or an `Error`.

An `ArithmeticException` is a subclass of `RuntimeException` and is thrown when an arithmetic operation fails due to certain conditions, such as division by zero or integer overflow.

Here's a program that demonstrates the use of `ArithmeticException` in Java:

```java
public class ArithmeticExceptionExample {
    public static void main(String[] args) {
        int dividend = 10;
        int divisor = 0;

        try {
            int quotient = dividend / divisor; // Division by zero will throw ArithmeticException
            System.out.println("Quotient: " + quotient);
        } catch (ArithmeticException e) {
            System.out.println("ArithmeticException caught: " + e.getMessage());
        }
    }
}
```

In this program:

- We have two integers, `dividend` and `divisor`, where `divisor` is initialized to 0.
- We attempt to perform a division operation (`dividend / divisor`), which will result in an `ArithmeticException` when `divisor` is 0.
- We have a `try-catch` block to handle the potential `ArithmeticException`. Inside the `try` block, the division operation is performed, and if an `ArithmeticException` occurs, it is caught by the `catch` block.
- Inside the `catch` block, we print a message indicating that an `ArithmeticException` was caught, along with the error message provided by the exception object (`e.getMessage()`).

When you run this program, it will output:

```
ArithmeticException caught: / by zero
```

This demonstrates how to use try-catch blocks to handle `ArithmeticException` and gracefully handle the error condition, preventing the program from crashing. It's important to handle exceptions appropriately in your code to ensure robustness and provide meaningful error messages to users.

## Q5a: Explain ArrayIndexOutOfBound Exception in Java with example.

In Java, `ArrayIndexOutOfBoundsException` is a runtime exception that occurs when you try to access an element of an array at an index that is outside the valid range of indices for that array. This means you are trying to access an array element with an index that is either negative or greater than or equal to the length of the array.

Here's an example to illustrate `ArrayIndexOutOfBoundsException`:

```java
public class ArrayIndexOutOfBoundsExceptionExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};

        // Accessing an element at an invalid index
        System.out.println("Element at index 3: " + numbers[3]); // This will throw ArrayIndexOutOfBoundsException
    }
}
```

In this example:

- We have an integer array `numbers` containing three elements: `1`, `2`, and `3`.
- We attempt to access the element at index `3` using `numbers[3]`.
- However, the valid indices for the array `numbers` are `0`, `1`, and `2`. Since we are trying to access an element at an index (`3`) that is beyond the valid range, it will result in an `ArrayIndexOutOfBoundsException` at runtime.

When you run this program, it will throw an `ArrayIndexOutOfBoundsException` with an error message similar to:

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
    at ArrayIndexOutOfBoundsExceptionExample.main(ArrayIndexOutOfBoundsExceptionExample.java:7)
```

To prevent `ArrayIndexOutOfBoundsException`, you should always ensure that the index used to access an array element is within the valid range of indices (i.e., between `0` and `array.length - 1`). You can use conditional statements or loop constructs to check the validity of array indices before accessing elements to handle such exceptions gracefully in your code.

## Q5b: Explain basics of Java stream classes.

In Java, stream classes are part of the Java I/O (Input/Output) API, which provides a way to efficiently read from and write to data sources and destinations, such as files, network connections, and memory buffers. Stream classes are used to handle input and output operations in Java programs, allowing data to be transferred between an application and external sources or sinks.

There are two main types of stream classes in Java:

1. **Byte Streams**:
   - Byte streams, represented by classes such as `InputStream` and `OutputStream`, are used for reading and writing raw bytes of data.
   - Byte streams are suitable for handling binary data or text data where character encoding is not a concern.
   - Examples of byte stream classes include `FileInputStream`, `FileOutputStream`, `BufferedInputStream`, `BufferedOutputStream`, etc.

2. **Character Streams**:
   - Character streams, represented by classes such as `Reader` and `Writer`, are used for reading and writing character data.
   - Character streams handle character encoding automatically, converting characters to and from bytes using the specified character encoding.
   - Character streams are suitable for reading and writing text data from/to external sources, ensuring proper character encoding and decoding.
   - Examples of character stream classes include `FileReader`, `FileWriter`, `BufferedReader`, `BufferedWriter`, etc.

Basics of using Java stream classes:

- **Reading from Streams**: To read data from a stream, you typically create an appropriate input stream class object (e.g., `FileInputStream` or `BufferedReader`), and then use methods provided by the stream class to read data from the source. For example:
  ```java
  BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
  String line = reader.readLine();
  ```

- **Writing to Streams**: To write data to a stream, you create an appropriate output stream class object (e.g., `FileOutputStream` or `BufferedWriter`), and then use methods provided by the stream class to write data to the destination. For example:
  ```java
  BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"));
  writer.write("Hello, World!");
  ```

- **Closing Streams**: It's important to close streams after using them to release system resources. You can use the `close()` method provided by stream classes to close the stream. Alternatively, you can use try-with-resources statement introduced in Java 7 to automatically close streams. For example:
  ```java
  try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
      String line = reader.readLine();
      // Process the data
  } catch (IOException e) {
      // Handle exception
  }
  ```

Java stream classes provide a flexible and efficient way to perform input and output operations in Java programs, making it easy to interact with external data sources and sinks. Whether you're reading from files, network connections, or writing data to them, Java stream classes offer a consistent and convenient API for handling I/O operations.

## Q5c: Write a java program to create a text file and perform read operation on the text file.

To create a text file and perform a read operation using `FileInputStream` in Java, you need to use `FileOutputStream` for writing to the file since `FileInputStream` is designed for reading bytes from a file. Below is a Java program that demonstrates how to create a text file using `FileOutputStream` and then reads it back using `FileInputStream`.

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileStreamExample {
    public static void main(String[] args) {
        String fileName = "sample.txt";
        String content = "Hello, World!\nThis is a sample text file.";

        // Write content to file
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(content.getBytes());
            System.out.println("File has been written successfully.");
        } catch (IOException e) {
            System.err.println("Error writing to file: " + e.getMessage());
        }

        // Read content from file
        try (FileInputStream fis = new FileInputStream(fileName)) {
            int i;
            System.out.println("Reading from file: ");
            while ((i = fis.read()) != -1) {
                // i is a byte. Convert it to char and print it
                System.out.print((char) i);
            }
        } catch (IOException e) {
            System.err.println("Error reading from file: " + e.getMessage());
        }
    }
}
```

In this program:

1. The `main` method defines a `fileName` for the file to be created and a `String` named `content` that holds the text to be written to the file.
2. It uses a `FileOutputStream` to write the text content to the file. The `String` content is converted to bytes using the `getBytes()` method before writing, as `FileOutputStream` works with bytes.
3. After writing the content to the file, it uses a `FileInputStream` to read the bytes from the file. It reads the file byte by byte in the `while` loop until `read()` returns `-1`, indicating the end of the file.
4. Each byte read from the file is cast to a `char` and printed to the console, allowing the text content of the file to be displayed.

This program demonstrates the basic use of `FileInputStream` and `FileOutputStream` for reading and writing text files, though it's worth noting that these classes are primarily intended for binary data. For reading and writing character data, consider using `FileReader` and `FileWriter` or `BufferedReader` and `BufferedWriter` for efficiency and simplicity.

## Q5a: Explain Divide by Zero Exception in Java with example.

In Java, a `DivideByZeroException` is not explicitly provided as a standard exception class. Instead, the exception that occurs when you attempt to divide by zero is called `ArithmeticException`. This exception is thrown when an arithmetic operation fails due to certain conditions, such as division by zero.

Here's an example to illustrate `ArithmeticException` (which commonly occurs due to divide by zero):

```java
public class DivideByZeroExceptionExample {
    public static void main(String[] args) {
        int dividend = 10;
        int divisor = 0;

        try {
            int quotient = dividend / divisor; // Division by zero will throw ArithmeticException
            System.out.println("Quotient: " + quotient);
        } catch (ArithmeticException e) {
            System.out.println("ArithmeticException caught: " + e.getMessage());
        }
    }
}
```

In this example:

- We have two integers, `dividend` and `divisor`, where `divisor` is initialized to `0`.
- We attempt to perform a division operation (`dividend / divisor`), which will result in an `ArithmeticException` when `divisor` is `0`.
- We have a `try-catch` block to handle the potential `ArithmeticException`. Inside the `try` block, the division operation is performed, and if an `ArithmeticException` occurs, it is caught by the `catch` block.
- Inside the `catch` block, we print a message indicating that an `ArithmeticException` was caught, along with the error message provided by the exception object (`e.getMessage()`).

When you run this program, it will output:

```
ArithmeticException caught: / by zero
```

This demonstrates how attempting to divide by zero results in an `ArithmeticException` being thrown at runtime in Java. To prevent such exceptions, it's important to ensure that you handle cases where division by zero may occur or validate input data to avoid such scenarios.

## Q5b: Explain java I/O process.

In Java, Input/Output (I/O) operations involve the exchange of data between a Java program and external sources or destinations, such as files, network connections, or other programs. The Java I/O process encompasses several key concepts and classes provided by the Java API to facilitate reading from and writing to various data sources and sinks.

The Java I/O process typically involves the following steps:

1. **Selecting a Data Source or Destination**:
   - Determine the source or destination of the data you want to read from or write to. This could be a file, network socket, standard input/output streams (e.g., `System.in` and `System.out`), or any other data stream.

2. **Creating Stream Objects**:
   - Once you've identified the source or destination, you need to create appropriate stream objects to interact with it.
   - For reading data, you typically use input stream classes such as `InputStream` or `Reader`.
   - For writing data, you typically use output stream classes such as `OutputStream` or `Writer`.
   - Stream classes provide methods for reading/writing data in the form of bytes or characters, depending on the type of data source or destination.

3. **Reading from or Writing to Streams**:
   - Use the methods provided by the stream classes to read data from or write data to the associated data source or destination.
   - For example, you can use methods like `read()` or `write()` to read/write bytes, or `readLine()` or `writeLine()` to read/write characters.

4. **Closing Streams**:
   - After you've finished reading from or writing to streams, it's important to close them to release system resources and ensure proper cleanup.
   - You can use the `close()` method provided by stream classes to close the streams.
   - Alternatively, you can use the try-with-resources statement introduced in Java 7 to automatically close streams when they are no longer needed.

5. **Handling Exceptions**:
   - I/O operations can throw exceptions due to various reasons, such as file not found, network errors, or invalid data formats.
   - It's essential to handle these exceptions gracefully using try-catch blocks or propagate them to the calling code for proper error handling and recovery.

6. **Optional: Buffering and Efficiency**:
   - To improve performance and efficiency, you can use buffered stream classes such as `BufferedReader`, `BufferedWriter`, `BufferedInputStream`, or `BufferedOutputStream`.
   - Buffered stream classes reduce the number of actual I/O operations by reading/writing data in larger chunks, resulting in improved performance.

Overall, the Java I/O process involves selecting the appropriate stream classes, reading from or writing to streams, closing streams after use, handling exceptions, and optionally using buffering for improved efficiency. Understanding these concepts and using the provided Java I/O classes effectively is crucial for performing input/output operations in Java programs.

## Q5c: Write a java program to display the content of a text file and perform append operation on the text file.

Below is a Java program that displays the content of a text file and performs an append operation on the text file using `FileInputStream` and `FileOutputStream`:

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileDisplayAndAppend {
    public static void main(String[] args) {
        String fileName = "sample.txt";

        // Display the content of the text file
        displayFileContent(fileName);

        // Perform append operation on the text file
        performAppendOperation(fileName);
    }

    // Method to display the content of the text file
    private static void displayFileContent(String fileName) {
        try (FileInputStream fis = new FileInputStream(fileName)) {
            int i;
            System.out.println("Contents of the text file:");
            while ((i = fis.read()) != -1) {
                System.out.print((char) i);
            }
            System.out.println("\n");
        } catch (IOException e) {
            System.err.println("Error reading from file: " + e.getMessage());
        }
    }

    // Method to perform append operation on the text file
    private static void performAppendOperation(String fileName) {
        String appendContent = "\nThis line is appended to the file.";

        try (FileOutputStream fos = new FileOutputStream(fileName, true)) {
            fos.write(appendContent.getBytes());
            System.out.println("Append operation completed successfully.");
        } catch (IOException e) {
            System.err.println("Error appending to file: " + e.getMessage());
        }
    }
}
```

In this program:

1. The `displayFileContent()` method reads and displays the content of the specified text file using `FileInputStream`.
2. The `performAppendOperation()` method appends a new line of content to the end of the text file using `FileOutputStream` with the `append` parameter set to `true`.
3. In the `main()` method, both methods are called sequentially to display the initial content of the file and then perform the append operation.
4. The content to be appended (`appendContent`) is specified as a `String` and converted to bytes using the `getBytes()` method before writing to the file.

When you run this program, it will display the initial content of the text file (if it exists) and then append a new line of content to the file. Make sure to replace `"sample.txt"` with the actual file name you want to read from and append to.